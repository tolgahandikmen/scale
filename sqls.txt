-- Backend-compatible PostgreSQL DDL for scale-backend
-- Schema name requested by user: "1scale"

BEGIN;

CREATE SCHEMA IF NOT EXISTS "1scale";

-- 1) Type master
CREATE TABLE IF NOT EXISTS "1scale".type (
  id SERIAL PRIMARY KEY,
  name VARCHAR(200) NOT NULL,
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE UNIQUE INDEX IF NOT EXISTS uq_type_name ON "1scale".type (LOWER(name));

-- 2) Item master (tree source)
CREATE TABLE IF NOT EXISTS "1scale".item_master (
  id SERIAL PRIMARY KEY,
  part_id VARCHAR(100) NOT NULL,
  part_sn VARCHAR(100) NOT NULL,
  bridge_name VARCHAR(200) NOT NULL,
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT uq_item_master UNIQUE (part_id, part_sn, bridge_name)
);

CREATE INDEX IF NOT EXISTS idx_item_master_part_id ON "1scale".item_master (part_id);
CREATE INDEX IF NOT EXISTS idx_item_master_part_sn ON "1scale".item_master (part_sn);

-- 3) Template header
CREATE TABLE IF NOT EXISTS "1scale".sheet_template (
  id SERIAL PRIMARY KEY,
  code VARCHAR(100) NOT NULL,
  name VARCHAR(255) NOT NULL,
  kind VARCHAR(20) NOT NULL,
  version INTEGER NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT ck_sheet_template_kind CHECK (kind IN ('INPUT', 'OUTPUT')),
  CONSTRAINT uq_sheet_template_code_version UNIQUE (code, version)
);

CREATE INDEX IF NOT EXISTS idx_sheet_template_kind ON "1scale".sheet_template (kind);
CREATE INDEX IF NOT EXISTS idx_sheet_template_code ON "1scale".sheet_template (code);

-- 4) Dynamic field definition
CREATE TABLE IF NOT EXISTS "1scale".field_definition (
  id SERIAL PRIMARY KEY,
  template_id INTEGER NOT NULL REFERENCES "1scale".sheet_template(id) ON DELETE CASCADE,
  key VARCHAR(200) NOT NULL,
  label VARCHAR(255) NOT NULL,
  type VARCHAR(30) NOT NULL,
  required BOOLEAN NOT NULL DEFAULT FALSE,
  order_no INTEGER NOT NULL DEFAULT 10,
  group_key VARCHAR(100),
  is_multi BOOLEAN NOT NULL DEFAULT FALSE,
  multi_keys_json JSONB NOT NULL DEFAULT '[]'::jsonb,
  unit_mode VARCHAR(20) NOT NULL DEFAULT 'NONE',
  unit_options_json JSONB NOT NULL DEFAULT '[]'::jsonb,
  dropdown_options_json JSONB NOT NULL DEFAULT '[]'::jsonb,
  table_schema_json JSONB,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  CONSTRAINT uq_field_template_key UNIQUE (template_id, key),
  CONSTRAINT ck_field_type CHECK (type IN ('TEXT', 'NUMBER', 'DATE', 'DROPDOWN', 'BOOLEAN', 'TABLE')),
  CONSTRAINT ck_field_unit_mode CHECK (unit_mode IN ('NONE', 'OPTIONAL', 'REQUIRED'))
);

CREATE INDEX IF NOT EXISTS idx_field_definition_template_id ON "1scale".field_definition (template_id);
CREATE INDEX IF NOT EXISTS idx_field_definition_type ON "1scale".field_definition (type);

-- 5) Item sheets (stores values in jsonb as backend expects)
CREATE TABLE IF NOT EXISTS "1scale".sheet_instance (
  id SERIAL PRIMARY KEY,
  item_id INTEGER NOT NULL REFERENCES "1scale".item_master(id) ON DELETE CASCADE,
  template_id INTEGER NOT NULL REFERENCES "1scale".sheet_template(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  sheet_date DATE,
  parent_sheet_id INTEGER REFERENCES "1scale".sheet_instance(id) ON DELETE CASCADE,
  output_template_id INTEGER REFERENCES "1scale".sheet_template(id),
  kind VARCHAR(20) NOT NULL,
  values_json JSONB NOT NULL DEFAULT '{}'::jsonb,
  CONSTRAINT ck_sheet_instance_kind CHECK (kind IN ('INPUT', 'OUTPUT'))
);

CREATE INDEX IF NOT EXISTS idx_sheet_instance_item_kind ON "1scale".sheet_instance (item_id, kind);
CREATE INDEX IF NOT EXISTS idx_sheet_instance_parent ON "1scale".sheet_instance (parent_sheet_id);
CREATE INDEX IF NOT EXISTS idx_sheet_instance_values_gin ON "1scale".sheet_instance USING GIN (values_json);

-- One OUTPUT per (input sheet, output template)
CREATE UNIQUE INDEX IF NOT EXISTS uq_sheet_instance_output_once
ON "1scale".sheet_instance(parent_sheet_id, output_template_id)
WHERE parent_sheet_id IS NOT NULL;

-- 6) Part-template rule table (matches backend integer[] access)
CREATE TABLE IF NOT EXISTS "1scale".part_template_mapping (
  part_id VARCHAR(100) PRIMARY KEY,
  input_template_ids INTEGER[] NOT NULL DEFAULT '{}'::INTEGER[],
  output_template_ids INTEGER[] NOT NULL DEFAULT '{}'::INTEGER[],
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_part_template_mapping_updated_at ON "1scale".part_template_mapping (updated_at DESC);

-- Optional: simple trigger for updated_at
CREATE OR REPLACE FUNCTION "1scale".set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_type_updated_at ON "1scale".type;
CREATE TRIGGER trg_type_updated_at
BEFORE UPDATE ON "1scale".type
FOR EACH ROW EXECUTE FUNCTION "1scale".set_updated_at();

DROP TRIGGER IF EXISTS trg_item_master_updated_at ON "1scale".item_master;
CREATE TRIGGER trg_item_master_updated_at
BEFORE UPDATE ON "1scale".item_master
FOR EACH ROW EXECUTE FUNCTION "1scale".set_updated_at();

DROP TRIGGER IF EXISTS trg_sheet_template_updated_at ON "1scale".sheet_template;
CREATE TRIGGER trg_sheet_template_updated_at
BEFORE UPDATE ON "1scale".sheet_template
FOR EACH ROW EXECUTE FUNCTION "1scale".set_updated_at();

DROP TRIGGER IF EXISTS trg_field_definition_updated_at ON "1scale".field_definition;
CREATE TRIGGER trg_field_definition_updated_at
BEFORE UPDATE ON "1scale".field_definition
FOR EACH ROW EXECUTE FUNCTION "1scale".set_updated_at();

COMMIT;
